"""
Sales Analytical Reports

Endpoints for sales analysis and insights.
"""

from decimal import Decimal
from datetime import date, datetime, timedelta
from typing import Dict, Any, List
import csv
import io
from django.http import HttpResponse
from django.db.models import Sum, Count, Avg, Q, F
from django.db.models.functions import ExtractHour, TruncDate
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status as http_status

from sales.models import Sale, SaleItem, Payment
from reports.services.report_base import BaseReportView
from reports.utils.response import ReportResponse, ReportError
from reports.utils.aggregation import AggregationHelper, PercentageCalculator
from reports.utils.profit_calculator import ProfitCalculator


"""
Sales Analytical Reports

Endpoints for sales analysis and insights.
"""

from decimal import Decimal
from datetime import date, timedelta
from typing import Dict, Any, List
from django.db.models import Sum, Count, Avg, Q, F
from django.db.models.functions import ExtractHour, TruncDate
from rest_framework.permissions import IsAuthenticated

from sales.models import Sale, SaleItem, Payment
from reports.services.report_base import BaseReportView
from reports.utils.response import ReportResponse, ReportError
from reports.utils.aggregation import AggregationHelper, PercentageCalculator
from reports.utils.profit_calculator import ProfitCalculator


class SalesSummaryReportView(BaseReportView):
    """
    Sales Summary Report (Updated to match frontend contract)
    
    GET /reports/api/sales/summary/
    
    Query Parameters:
    - start_date: YYYY-MM-DD (default: 30 days ago)
    - end_date: YYYY-MM-DD (default: today)
    - storefront_id: UUID (optional)
    - sale_type: RETAIL or WHOLESALE (optional)
    - period_type: daily, weekly, monthly (default: daily)
    - compare_previous: boolean (default: true)
    
    Returns (matching frontend SalesSummaryResponse):
    {
      "success": true,
      "data": {
        "summary": {...},
        "results": { // Modified to match frontend expectation
          "summary": {...},
          "breakdown": [...],
          "top_selling_hours": [...],
          "comparison": {...}
        },
        "metadata": {...}
      }
    }
    """
    
    permission_classes = [IsAuthenticated]
    
    def get(self, request, *args, **kwargs):
        # Get business ID
        business_id, error = self.get_business_or_error(request)
        if error:
            return ReportResponse.error(error)
        
        # Get date range
        start_date, end_date, error = self.get_date_range(request)
        if error:
            return ReportResponse.error(error)
        
        # Get base queryset
        queryset = Sale.objects.filter(business_id=business_id)
        
        # Apply date filter
        queryset = queryset.filter(
            created_at__date__gte=start_date,
            created_at__date__lte=end_date
        )
        
        # Apply optional filters
        storefront_id = request.query_params.get('storefront_id')
        if storefront_id:
            queryset = queryset.filter(storefront_id=storefront_id)
        
        sale_type = request.query_params.get('sale_type')
        if sale_type and sale_type in ['RETAIL', 'WHOLESALE']:
            queryset = queryset.filter(type=sale_type)
        
        # Only completed sales
        queryset = queryset.filter(status='COMPLETED')
        
        # Get period type
        period_type = request.query_params.get('period_type', 'daily')
        
        # Build comparison data if requested
        compare_previous = request.query_params.get('compare_previous', 'true').lower() == 'true'
        comparison_data = None
        growth_rate = 0.0
        
        if compare_previous:
            # Calculate previous period dates
            days_diff = (end_date - start_date).days + 1
            prev_end_date = start_date - timedelta(days=1)
            prev_start_date = prev_end_date - timedelta(days=days_diff - 1)
            
            # Get previous period queryset
            prev_queryset = Sale.objects.filter(
                business_id=business_id,
                status='COMPLETED',
                created_at__date__gte=prev_start_date,
                created_at__date__lte=prev_end_date
            )
            
            # Apply same filters
            if storefront_id:
                prev_queryset = prev_queryset.filter(storefront_id=storefront_id)
            if sale_type:
                prev_queryset = prev_queryset.filter(type=sale_type)
            
            comparison_data, growth_rate = self._build_comparison(
                queryset, prev_queryset, prev_start_date, prev_end_date
            )
        
        # Build summary (with growth rate from comparison)
        summary = self._build_summary(queryset, start_date, end_date, period_type, growth_rate)
        
        # Build breakdown (daily breakdown with frontend field names)
        breakdown = self._build_period_breakdown(queryset, period_type)
        
        # Build top selling hours
        top_selling_hours = self._build_hourly_analysis(queryset)
        
        # Build the nested results structure that frontend expects
        results_data = {
            'summary': summary,
            'breakdown': breakdown,
            'top_selling_hours': top_selling_hours,
        }
        
        if comparison_data:
            results_data['comparison'] = comparison_data
        
        # Build metadata
        metadata = self.build_metadata(
            start_date=start_date,
            end_date=end_date,
            filters={
                'storefront_id': storefront_id,
                'sale_type': sale_type,
                'period_type': period_type,
                'compare_previous': compare_previous,
            }
        )
        
        # Return with standard response wrapper
        # Frontend expects: response.data.data.summary, response.data.data.breakdown, etc.
        # Custom response structure for sales summary (matches frontend contract)
        response_data = {
            "success": True,
            "data": {
                "summary": summary,
                "breakdown": breakdown,
                "top_selling_hours": top_selling_hours,
            },
            "error": None
        }
        
        # Add comparison if available
        if comparison_data:
            response_data["data"]["comparison"] = comparison_data
        
        # Add metadata
        response_data["metadata"] = {
            "generated_at": datetime.utcnow().isoformat() + "Z",
            **metadata
        }
        
        return Response(response_data, status=http_status.HTTP_200_OK)
    
    def _build_summary(self, queryset, start_date, end_date, period_type, growth_rate) -> Dict[str, Any]:
        """Build summary metrics matching frontend SalesSummary interface"""
        
        # Total transactions (renamed from total_sales)
        total_transactions = queryset.count()
        
        # Total sales revenue
        total_sales = AggregationHelper.sum_field(queryset, 'total_amount')
        
        # Total discounts given
        total_discounts_given = AggregationHelper.sum_field(queryset, 'discount_amount')
        
        # Net sales (sales - discounts)
        net_sales = total_sales - total_discounts_given
        
        # Average transaction value (renamed from average_order_value)
        average_transaction_value = AggregationHelper.avg_field(queryset, 'total_amount')
        
        # Total items sold
        total_items_sold = SaleItem.objects.filter(
            sale__in=queryset
        ).aggregate(
            total=Sum('quantity')
        )['total'] or 0
        
        # Total unique customers
        total_customers = queryset.filter(
            customer__isnull=False
        ).values('customer').distinct().count()
        
        return {
            'total_sales': float(total_sales),
            'total_transactions': total_transactions,
            'average_transaction_value': float(average_transaction_value),
            'total_items_sold': total_items_sold,
            'total_customers': total_customers,
            'total_discounts_given': float(total_discounts_given),
            'net_sales': float(net_sales),
            'growth_rate': float(growth_rate),
            'period': {
                'start': str(start_date),
                'end': str(end_date),
                'type': period_type
            }
        }
    
    def _build_period_breakdown(self, queryset, period_type) -> List[Dict[str, Any]]:
        """Build period breakdown matching frontend SalesBreakdown interface"""
        
        # Group by date
        daily_data = queryset.annotate(
            date=TruncDate('created_at')
        ).values('date').annotate(
            revenue=Sum('total_amount'),
            transaction_count=Count('id')
        ).order_by('date')
        
        breakdown = []
        for item in daily_data:
            day_date = item['date']
            day_sales = queryset.filter(created_at__date=day_date)
            
            # Count items sold for this day
            items_sold = SaleItem.objects.filter(
                sale__in=day_sales
            ).aggregate(total=Sum('quantity'))['total'] or 0
            
            # Count unique customers for this day
            customers = day_sales.filter(
                customer__isnull=False
            ).values('customer').distinct().count()
            
            breakdown.append({
                'period': str(day_date),
                'sales': float(item['revenue']),
                'transactions': item['transaction_count'],
                'avg_value': float(item['revenue'] / item['transaction_count']) if item['transaction_count'] > 0 else 0.0,
                'items_sold': items_sold,
                'customers': customers
            })
        
        return breakdown
    
    def _build_hourly_analysis(self, queryset) -> List[Dict[str, Any]]:
        """Build hourly sales analysis matching frontend TopSellingHour interface"""
        
        # Group sales by hour of day
        hourly_data = queryset.annotate(
            hour=ExtractHour('created_at')
        ).values('hour').annotate(
            revenue=Sum('total_amount'),
            transaction_count=Count('id')
        ).order_by('-revenue')  # Sort by revenue descending
        
        # Convert to list and take top 10
        top_hours = []
        for item in hourly_data[:10]:
            top_hours.append({
                'hour': item['hour'],
                'sales': float(item['revenue']),
                'transactions': item['transaction_count']
            })
        
        return top_hours
    
    def _build_comparison(self, current_queryset, previous_queryset, prev_start, prev_end):
        """Build previous period comparison matching frontend PeriodComparison interface"""
        
        # Current period metrics
        current_sales = AggregationHelper.sum_field(current_queryset, 'total_amount')
        current_transactions = current_queryset.count()
        
        # Previous period metrics
        previous_sales = AggregationHelper.sum_field(previous_queryset, 'total_amount')
        previous_transactions = previous_queryset.count()
        
        # Calculate growth rate
        if previous_sales > 0:
            growth = ((current_sales - previous_sales) / previous_sales) * 100
        else:
            growth = 100.0 if current_sales > 0 else 0.0
        
        comparison = {
            'previous_period': {
                'start': str(prev_start),
                'end': str(prev_end),
                'total_sales': float(previous_sales),
                'total_transactions': previous_transactions,
                'growth': float(growth)
            }
        }
        
        return comparison, growth
    
    # Keep old methods for backward compatibility
    def _get_payment_breakdown(self, queryset) -> List[Dict[str, Any]]:
        """Get sales breakdown by payment method"""
        
        # Get all payments for these sales
        payments = Payment.objects.filter(sale__in=queryset)
        
        # Group by payment method
        breakdown = list(
            payments.values('payment_method')
            .annotate(
                count=Count('id'),
                total=Sum('amount_paid')
            )
            .order_by('-total')
        )
        
        # Calculate percentages
        total = sum(Decimal(str(item['total'])) for item in breakdown)
        for item in breakdown:
            item['total'] = float(item['total'])
            item['percentage'] = float(
                AggregationHelper.calculate_percentage(
                    Decimal(str(item['total'])),
                    total
                )
            )
        
        return breakdown
    
    def _get_type_breakdown(self, queryset) -> List[Dict[str, Any]]:
        """Get sales breakdown by sale type"""
        
        breakdown = list(
            queryset.values('type')
            .annotate(
                count=Count('id'),
                total=Sum('total_amount')
            )
            .order_by('-total')
        )
        
        # Calculate percentages
        total = sum(Decimal(str(item['total'] or 0)) for item in breakdown)
        for item in breakdown:
            item['total'] = float(item['total'] or 0)
            item['percentage'] = float(
                AggregationHelper.calculate_percentage(
                    Decimal(str(item['total'])),
                    total
                )
            ) if total > 0 else 0.0
        
        return breakdown
    
    def _build_daily_breakdown(self, queryset) -> List[Dict[str, Any]]:
        """Build daily sales breakdown (deprecated - kept for compatibility)"""
        
        daily_data = AggregationHelper.group_by_date(
            queryset,
            date_field='created_at',
            value_field='total_amount',
            aggregation='sum'
        )
        
        # Add count and average
        for item in daily_data:
            date_sales = queryset.filter(created_at__date=item['date'])
            item['count'] = date_sales.count()
            item['revenue'] = float(item.pop('value', 0))
            item['average'] = float(
                item['revenue'] / item['count'] if item['count'] > 0 else 0
            )
            item['date'] = str(item['date'])
        
        return daily_data
    
    def _handle_export(self, request, export_format):
        """Handle export requests in CSV, Excel, or PDF format"""
        # Get business ID
        business_id, error = self.get_business_or_error(request)
        if error:
            return Response(
                {'error': str(error)},
                status=http_status.HTTP_400_BAD_REQUEST
            )
        
        # Get date range
        start_date, end_date, error = self.get_date_range(request)
        if error:
            return Response(
                {'error': str(error)},
                status=http_status.HTTP_400_BAD_REQUEST
            )
        
        # Get base queryset
        queryset = Sale.objects.filter(business_id=business_id)
        
        # Apply date filter
        queryset = queryset.filter(
            created_at__date__gte=start_date,
            created_at__date__lte=end_date
        )
        
        # Apply optional filters
        storefront_id = request.query_params.get('storefront_id')
        if storefront_id:
            queryset = queryset.filter(storefront_id=storefront_id)
        
        sale_type = request.query_params.get('sale_type')
        if sale_type and sale_type in ['RETAIL', 'WHOLESALE']:
            queryset = queryset.filter(type=sale_type)
        
        # Only completed sales
        queryset = queryset.filter(status='COMPLETED')
        
        # Get period type
        period_type = request.query_params.get('period_type', 'daily')
        
        # Build data
        summary = self._build_summary(queryset, start_date, end_date, period_type, 0.0)
        breakdown = self._build_period_breakdown(queryset, period_type)
        top_hours = self._build_hourly_analysis(queryset)
        
        # Export based on format
        if export_format == 'csv':
            return self._export_csv(summary, breakdown, top_hours, start_date, end_date)
        elif export_format == 'excel':
            return Response(
                {'error': 'Excel format not yet implemented. Please use CSV.'},
                status=http_status.HTTP_501_NOT_IMPLEMENTED
            )
        elif export_format == 'pdf':
            return Response(
                {'error': 'PDF format not yet implemented. Please use CSV.'},
                status=http_status.HTTP_501_NOT_IMPLEMENTED
            )
    
    def _export_csv(self, summary, breakdown, top_hours, start_date, end_date):
        """Export sales summary as CSV"""
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Header
        writer.writerow(['Sales Summary Report'])
        writer.writerow([f'Period: {start_date} to {end_date}'])
        writer.writerow([f'Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}'])
        writer.writerow([])
        
        # Summary section
        writer.writerow(['SUMMARY METRICS'])
        writer.writerow(['Metric', 'Value'])
        writer.writerow(['Total Sales (Revenue)', f"${summary['total_sales']:,.2f}"])
        writer.writerow(['Total Transactions', summary['total_transactions']])
        writer.writerow(['Average Transaction Value', f"${summary['average_transaction_value']:,.2f}"])
        writer.writerow(['Total Items Sold', summary['total_items_sold']])
        writer.writerow(['Total Customers', summary['total_customers']])
        writer.writerow(['Total Discounts Given', f"${summary['total_discounts_given']:,.2f}"])
        writer.writerow(['Net Sales', f"${summary['net_sales']:,.2f}"])
        writer.writerow(['Growth Rate vs Previous Period', f"{summary['growth_rate']:.1f}%"])
        writer.writerow([])
        
        # Daily breakdown section
        writer.writerow(['DAILY BREAKDOWN'])
        writer.writerow(['Date', 'Sales', 'Transactions', 'Avg Value', 'Items Sold', 'Customers'])
        
        for item in breakdown:
            writer.writerow([
                item['period'],
                f"${item['sales']:,.2f}",
                item['transactions'],
                f"${item['avg_value']:,.2f}",
                item['items_sold'],
                item['customers']
            ])
        
        writer.writerow([])
        
        # Top selling hours section
        writer.writerow(['TOP SELLING HOURS'])
        writer.writerow(['Hour', 'Sales', 'Transactions'])
        
        for item in top_hours:
            hour_str = f"{item['hour']}:00" if item['hour'] < 12 else f"{item['hour']}:00"
            writer.writerow([
                hour_str,
                f"${item['sales']:,.2f}",
                item['transactions']
            ])
        
        # Generate response
        output.seek(0)
        response = HttpResponse(output.getvalue(), content_type='text/csv; charset=utf-8')
        filename = f'sales-summary-{start_date}-to-{end_date}.csv'
        response['Content-Disposition'] = f'attachment; filename="{filename}"'
        
        return response


class ProductPerformanceReportView(BaseReportView):
    """
    Product Performance Report
    
    GET /reports/api/sales/products/
    
    Query Parameters:
    - start_date: YYYY-MM-DD (default: 30 days ago)
    - end_date: YYYY-MM-DD (default: today)
    - storefront_id: UUID (optional)
    - limit: int (default: 50, max: 500)
    - sort_by: revenue, quantity, profit (default: revenue)
    
    Returns:
    - Top selling products by revenue/quantity
    - Product profit analysis
    - Performance metrics per product
    """
    
    permission_classes = [IsAuthenticated]
    
    def get(self, request, *args, **kwargs):
        # Get business ID
        business_id, error = self.get_business_or_error(request)
        if error:
            return ReportResponse.error(error)
        
        # Get date range
        start_date, end_date, error = self.get_date_range(request)
        if error:
            return ReportResponse.error(error)
        
        # Get pagination params
        page, page_size = self.get_pagination_params(request)
        
        # Get sort parameter
        sort_by = request.query_params.get('sort_by', 'revenue')
        if sort_by not in ['revenue', 'quantity', 'profit']:
            sort_by = 'revenue'
        
        # Get base queryset - SaleItems from completed sales
        queryset = SaleItem.objects.filter(
            sale__business_id=business_id,
            sale__status='COMPLETED',
            sale__created_at__date__gte=start_date,
            sale__created_at__date__lte=end_date
        )
        
        # Apply optional filters
        storefront_id = request.query_params.get('storefront_id')
        if storefront_id:
            queryset = queryset.filter(sale__storefront_id=storefront_id)
        
        # Build summary
        summary = self._build_summary(queryset)
        
        # Build results (product performance)
        results, total_count = self._build_product_performance(
            queryset, sort_by, page, page_size
        )
        
        # Build metadata
        metadata = self.build_metadata(
            start_date=start_date,
            end_date=end_date,
            filters={
                'storefront_id': storefront_id,
                'sort_by': sort_by,
            }
        )
        
        return ReportResponse.paginated(
            summary, results, metadata, page, page_size, total_count
        )
    
    def _build_summary(self, queryset) -> Dict[str, Any]:
        """Build summary metrics"""
        
        total_products = queryset.values('product').distinct().count()
        total_items_sold = AggregationHelper.sum_field(queryset, 'quantity')
        total_revenue = AggregationHelper.sum_field(queryset, 'total_price')
        
        # Note: Profit calculation for individual SaleItems is complex because it requires
        # looking up cost from StockProduct. For now, we'll return 0 or calculate it
        # differently. The sales-level profit is more accurate via ProfitCalculator.
        total_profit = Decimal('0.00')  # TODO: Implement SaleItem-level profit calculation
        
        profit_margin = AggregationHelper.calculate_percentage(
            total_profit, total_revenue
        ) if total_revenue > 0 else Decimal('0.00')
        
        return {
            'total_products_sold': total_products,
            'total_items_sold': float(total_items_sold),
            'total_revenue': float(total_revenue),
            'total_profit': float(total_profit),
            'overall_profit_margin': float(profit_margin),
        }
    
    def _build_product_performance(
        self, queryset, sort_by: str, page: int, page_size: int
    ) -> tuple[List[Dict[str, Any]], int]:
        """Build product performance breakdown"""
        
        # Aggregate by product
        product_data = queryset.values(
            'product__id',
            'product__name',
            'product__sku'
        ).annotate(
            quantity_sold=Sum('quantity'),
            revenue=Sum('total_price'),
            times_sold=Count('sale', distinct=True)
        )
        
        # Calculate profit margin for each
        # Note: Profit calculation requires cost lookup from StockProduct,
        # which is complex in aggregation. Returning 0 for now.
        results = []
        for item in product_data:
            revenue = Decimal(str(item['revenue'] or 0))
            profit = Decimal('0.00')  # TODO: Implement product-level profit calculation
            
            profit_margin = AggregationHelper.calculate_percentage(
                profit, revenue
            ) if revenue > 0 else Decimal('0.00')
            
            results.append({
                'product_id': str(item['product__id']),
                'product_name': item['product__name'],
                'sku': item['product__sku'],
                'quantity_sold': float(item['quantity_sold']),
                'revenue': float(revenue),
                'profit': float(profit),
                'profit_margin': float(profit_margin),
                'times_sold': item['times_sold'],
            })
        
        # Sort by requested field
        sort_field = {
            'revenue': 'revenue',
            'quantity': 'quantity_sold',
            'profit': 'profit',
        }[sort_by]
        
        results = sorted(results, key=lambda x: x[sort_field], reverse=True)
        
        # Paginate
        total_count = len(results)
        start = (page - 1) * page_size
        end = start + page_size
        paginated_results = results[start:end]
        
        # Add rank
        for idx, item in enumerate(paginated_results, start=start + 1):
            item['rank'] = idx
        
        return paginated_results, total_count


class CustomerAnalyticsReportView(BaseReportView):
    """
    Customer Analytics Report (via Sales)
    
    GET /reports/api/sales/customer-analytics/
    
    Query Parameters:
    - start_date: YYYY-MM-DD (default: 30 days ago)
    - end_date: YYYY-MM-DD (default: today)
    - storefront_id: UUID (optional)
    - sort_by: revenue, frequency, avg_order, recency (default: revenue)
    - page, page_size (pagination)
    
    Returns:
    - Top customers by purchase metrics
    - Customer purchase frequency
    - Average order value per customer
    - Recency analysis
    - Customer contribution percentages
    """
    
    permission_classes = [IsAuthenticated]
    
    def get(self, request, *args, **kwargs):
        from django.db.models import Min, Max
        from django.utils import timezone
        
        # Get business ID
        business_id, error = self.get_business_or_error(request)
        if error:
            return ReportResponse.error(error)
        
        # Get date range
        start_date, end_date, error = self.get_date_range(request)
        if error:
            return ReportResponse.error(error)
        
        # Get pagination params
        page, page_size = self.get_pagination_params(request)
        
        # Get sort parameter
        sort_by = request.query_params.get('sort_by', 'revenue')
        if sort_by not in ['revenue', 'frequency', 'avg_order', 'recency']:
            sort_by = 'revenue'
        
        # Get base queryset - completed sales with customers
        queryset = Sale.objects.filter(
            business_id=business_id,
            status='COMPLETED',
            customer__isnull=False,  # Only sales with customers
            created_at__date__gte=start_date,
            created_at__date__lte=end_date
        )
        
        # Apply optional filters
        storefront_id = request.query_params.get('storefront_id')
        if storefront_id:
            queryset = queryset.filter(storefront_id=storefront_id)
        
        # Aggregate by customer
        customer_data = queryset.values(
            'customer__id',
            'customer__name',
            'customer__email',
        ).annotate(
            total_spent=Sum('total_amount'),
            order_count=Count('id'),
            first_purchase=Min('created_at'),
            last_purchase=Max('created_at')
        )
        
        # Build summary
        total_customers = customer_data.count()
        total_revenue = AggregationHelper.sum_field(queryset, 'total_amount')
        total_orders = queryset.count()
        
        avg_revenue_per_customer = AggregationHelper.safe_divide(
            total_revenue,
            Decimal(str(total_customers))
        ) if total_customers > 0 else Decimal('0.00')
        
        avg_orders_per_customer = total_orders / total_customers if total_customers > 0 else 0
        
        # Calculate repeat customer rate
        repeat_customers = sum(1 for c in customer_data if c['order_count'] > 1)
        repeat_rate = AggregationHelper.calculate_percentage(
            Decimal(str(repeat_customers)),
            Decimal(str(total_customers))
        ) if total_customers > 0 else Decimal('0.00')
        
        summary = {
            'total_customers': total_customers,
            'total_revenue': float(total_revenue),
            'total_orders': total_orders,
            'average_revenue_per_customer': float(avg_revenue_per_customer),
            'average_orders_per_customer': round(avg_orders_per_customer, 2),
            'repeat_customer_rate': float(repeat_rate),
        }
        
        # Build results with calculated fields
        results = []
        for item in customer_data:
            total_spent = Decimal(str(item['total_spent'] or 0))
            order_count = item['order_count']
            
            avg_order_value = AggregationHelper.safe_divide(
                total_spent,
                Decimal(str(order_count))
            )
            
            contribution_pct = AggregationHelper.calculate_percentage(
                total_spent,
                total_revenue
            ) if total_revenue > 0 else Decimal('0.00')
            
            # Calculate days since last purchase
            last_purchase = item['last_purchase']
            if last_purchase:
                days_since = (timezone.now().date() - last_purchase.date()).days
            else:
                days_since = None
            
            results.append({
                'customer_id': str(item['customer__id']),
                'customer_name': item['customer__name'],
                'customer_email': item['customer__email'],
                'total_spent': float(total_spent),
                'order_count': order_count,
                'average_order_value': float(avg_order_value),
                'contribution_percentage': float(contribution_pct),
                'first_purchase_date': item['first_purchase'].date().isoformat() if item['first_purchase'] else None,
                'last_purchase_date': item['last_purchase'].date().isoformat() if item['last_purchase'] else None,
                'days_since_last_purchase': days_since,
            })
        
        # Sort by requested field
        sort_field_map = {
            'revenue': 'total_spent',
            'frequency': 'order_count',
            'avg_order': 'average_order_value',
            'recency': 'days_since_last_purchase',
        }
        sort_field = sort_field_map[sort_by]
        
        # For recency, sort ascending (most recent first)
        reverse = (sort_by != 'recency')
        
        # Handle None values in recency sorting
        if sort_by == 'recency':
            results = sorted(
                results,
                key=lambda x: x[sort_field] if x[sort_field] is not None else float('inf'),
                reverse=False
            )
        else:
            results = sorted(results, key=lambda x: x[sort_field], reverse=reverse)
        
        # Paginate
        total_count = len(results)
        start = (page - 1) * page_size
        end = start + page_size
        paginated_results = results[start:end]
        
        # Add rank
        for idx, item in enumerate(paginated_results, start=start + 1):
            item['rank'] = idx
        
        # Build metadata
        metadata = self.build_metadata(
            start_date=start_date,
            end_date=end_date,
            filters={
                'storefront_id': storefront_id,
                'sort_by': sort_by,
            }
        )
        
        return ReportResponse.paginated(
            summary, paginated_results, metadata, page, page_size, total_count
        )


class RevenueTrendsReportView(BaseReportView):
    """
    Revenue Trends Report
    
    GET /reports/api/sales/revenue-trends/
    
    Query Parameters:
    - start_date: YYYY-MM-DD (default: 30 days ago)
    - end_date: YYYY-MM-DD (default: today)
    - storefront_id: UUID (optional)
    - grouping: daily, weekly, monthly (default: daily)
    - compare: boolean (default: false) - compare to previous period
    
    Returns:
    - Time-series revenue data
    - Growth rates
    - Trend indicators
    - Comparison with previous period (if requested)
    """
    
    permission_classes = [IsAuthenticated]
    
    def get(self, request, *args, **kwargs):
        from django.db.models.functions import TruncDate, TruncWeek, TruncMonth
        from datetime import timedelta
        
        # Get business ID
        business_id, error = self.get_business_or_error(request)
        if error:
            return ReportResponse.error(error)
        
        # Get date range
        start_date, end_date, error = self.get_date_range(request, max_days=365)
        if error:
            return ReportResponse.error(error)
        
        # Get grouping parameter
        grouping = request.query_params.get('grouping', 'daily')
        if grouping not in ['daily', 'weekly', 'monthly']:
            grouping = 'daily'
        
        # Get comparison flag
        compare = request.query_params.get('compare', '').lower() == 'true'
        
        # Get base queryset
        queryset = Sale.objects.filter(
            business_id=business_id,
            status='COMPLETED',
            created_at__date__gte=start_date,
            created_at__date__lte=end_date
        )
        
        # Apply optional filters
        storefront_id = request.query_params.get('storefront_id')
        if storefront_id:
            queryset = queryset.filter(storefront_id=storefront_id)
        
        # Get previous period data if comparison requested
        previous_data = None
        if compare:
            duration = (end_date - start_date).days
            prev_end = start_date - timedelta(days=1)
            prev_start = prev_end - timedelta(days=duration)
            
            prev_queryset = Sale.objects.filter(
                business_id=business_id,
                status='COMPLETED',
                created_at__date__gte=prev_start,
                created_at__date__lte=prev_end
            )
            if storefront_id:
                prev_queryset = prev_queryset.filter(storefront_id=storefront_id)
            
            previous_data = {
                'start_date': prev_start,
                'end_date': prev_end,
                'queryset': prev_queryset
            }
        
        # Build summary
        summary = self._build_summary(queryset, start_date, end_date, previous_data)
        
        # Build results (time-series data)
        results = self._build_time_series(queryset, grouping, start_date, end_date)
        
        # Build metadata
        metadata = self.build_metadata(
            start_date=start_date,
            end_date=end_date,
            filters={
                'storefront_id': storefront_id,
                'grouping': grouping,
                'compare_to_previous': compare,
            }
        )
        
        return ReportResponse.success(summary, results, metadata)
    
    def _build_summary(
        self, queryset, start_date, end_date, previous_data
    ) -> Dict[str, Any]:
        """Build summary metrics"""
        
        total_revenue = AggregationHelper.sum_field(queryset, 'total_amount')
        total_orders = queryset.count()
        total_profit = ProfitCalculator.calculate_total_profit(queryset)
        
        # Calculate averages
        days_in_period = (end_date - start_date).days + 1
        avg_daily_revenue = AggregationHelper.safe_divide(
            total_revenue,
            Decimal(str(days_in_period))
        )
        
        avg_order_value = AggregationHelper.safe_divide(
            total_revenue,
            Decimal(str(total_orders))
        ) if total_orders > 0 else Decimal('0.00')
        
        # Find peak day
        daily_sales = queryset.extra(
            select={'date': 'DATE(created_at)'}
        ).values('date').annotate(
            revenue=Sum('total_amount')
        ).order_by('-revenue').first()
        
        peak_day = daily_sales['date'] if daily_sales else None
        peak_revenue = Decimal(str(daily_sales['revenue'])) if daily_sales else Decimal('0.00')
        
        summary = {
            'period_start': str(start_date),
            'period_end': str(end_date),
            'total_revenue': float(total_revenue),
            'total_profit': float(total_profit),
            'total_orders': total_orders,
            'average_daily_revenue': float(avg_daily_revenue),
            'average_order_value': float(avg_order_value),
            'peak_day': str(peak_day) if peak_day else None,
            'peak_revenue': float(peak_revenue),
        }
        
        # Add comparison if previous period data provided
        if previous_data:
            prev_revenue = AggregationHelper.sum_field(
                previous_data['queryset'], 'total_amount'
            )
            prev_orders = previous_data['queryset'].count()
            prev_profit = ProfitCalculator.calculate_total_profit(previous_data['queryset'])
            
            revenue_growth = AggregationHelper.calculate_growth_rate(
                total_revenue, prev_revenue
            )
            order_growth = AggregationHelper.calculate_growth_rate(
                Decimal(str(total_orders)), Decimal(str(prev_orders))
            )
            profit_growth = AggregationHelper.calculate_growth_rate(
                total_profit, prev_profit
            )
            
            summary['previous_period'] = {
                'start': str(previous_data['start_date']),
                'end': str(previous_data['end_date']),
                'revenue': float(prev_revenue),
                'profit': float(prev_profit),
                'orders': prev_orders,
            }
            
            summary['comparison'] = {
                'revenue_growth': float(revenue_growth),
                'order_growth': float(order_growth),
                'profit_growth': float(profit_growth),
                'revenue_change': float(total_revenue - prev_revenue),
                'order_change': total_orders - prev_orders,
            }
        
        return summary
    
    def _build_time_series(
        self, queryset, grouping: str, start_date, end_date
    ) -> List[Dict[str, Any]]:
        """Build time-series data"""
        
        from django.db.models.functions import TruncDate, TruncWeek, TruncMonth
        
        # Select truncation function based on grouping
        trunc_func = {
            'daily': TruncDate('created_at'),
            'weekly': TruncWeek('created_at'),
            'monthly': TruncMonth('created_at'),
        }[grouping]
        
        # Group by period
        time_series = list(
            queryset
            .annotate(period=trunc_func)
            .values('period')
            .annotate(
                revenue=Sum('total_amount'),
                order_count=Count('id')
            )
            .order_by('period')
        )
        
        # Calculate profit for each period
        # Note: We need to calculate profit separately for each period since it's not a direct field
        period_profits = {}
        for item in time_series:
            period = item['period']
            
            # Filter sales for this period based on grouping type
            if grouping == 'daily':
                # period is already a date object from TruncDate
                period_sales = queryset.filter(created_at__date=period)
            elif grouping == 'weekly':
                # For weekly, filter by the week start date (period is a datetime)
                period_sales = queryset.annotate(week=TruncWeek('created_at')).filter(week=period)
            elif grouping == 'monthly':
                # For monthly, filter by the month start date (period is a datetime)
                period_sales = queryset.annotate(month=TruncMonth('created_at')).filter(month=period)
            else:
                # Default to daily filtering
                period_sales = queryset.filter(created_at__date=period)
            
            period_profits[str(period)] = ProfitCalculator.calculate_total_profit(period_sales)
        
        # Format results
        results = []
        prev_revenue = None
        
        for idx, item in enumerate(time_series):
            revenue = Decimal(str(item['revenue'] or 0))
            profit = period_profits.get(str(item['period']), Decimal('0.00'))
            order_count = item['order_count']
            
            # Calculate profit margin
            profit_margin = AggregationHelper.calculate_percentage(
                profit, revenue
            ) if revenue > 0 else Decimal('0.00')
            
            # Calculate period-over-period growth
            growth_rate = None
            if prev_revenue is not None and prev_revenue > 0:
                growth_rate = float(
                    AggregationHelper.calculate_growth_rate(revenue, prev_revenue)
                )
            
            # Determine trend
            trend = 'stable'
            if growth_rate is not None:
                if growth_rate > 5:
                    trend = 'up'
                elif growth_rate < -5:
                    trend = 'down'
            
            # Convert period to ISO format string
            period_value = item['period']
            if period_value:
                # Check if it's already a date or needs conversion from datetime
                if hasattr(period_value, 'date') and not isinstance(period_value, date):
                    period_str = period_value.date().isoformat()
                else:
                    period_str = period_value.isoformat()
            else:
                period_str = None
            
            result = {
                'period': period_str,
                'revenue': float(revenue),
                'profit': float(profit),
                'profit_margin': float(profit_margin),
                'order_count': order_count,
                'average_order_value': float(
                    revenue / order_count if order_count > 0 else 0
                ),
            }
            
            if growth_rate is not None:
                result['growth_rate'] = growth_rate
                result['trend'] = trend
            
            results.append(result)
            prev_revenue = revenue
        
        return results

